* Autoloads
** mcordell/normalize-name-to-tag
Given a name, convert it to a org-header tag
#+begin_src emacs-lisp :tangle autoload/my-org.el
;;;###autoload
(defun mcordell/normalize-name-to-tag (name)
  "Convert NAME to a tag-friendly string, e.g. \"Brian\" -> \"brian\"."
  (let* ((lower (downcase name)))
    (replace-regexp-in-string "[^a-z0-9_@#%]+" "_" lower)))
#+end_src

** mcordell/agenda-one-on-one-for-name
Core function that shows open TODOs tagged with a specific person's name. Takes the name as a parameter rather than prompting.
#+begin_src emacs-lisp :tangle autoload/my-org.el
;;;###autoload
(defun mcordell/agenda-one-on-one-for-name (name)
  "Show open TODOs tagged with the specified NAME."
  (let* ((when-str (or (cdr (assoc name mcordell/one-on-one-list)) ""))  ; optional, for header
         (tag (mcordell/normalize-name-to-tag name))
         ;; Localize agenda files only for this command:
         (org-agenda-files (directory-files-recursively mcordell/one-on-one-files-dir "\\.org\\'"))
         ;; Nice header
         (org-agenda-overriding-header
          (format "Open TODOs for %s  %s" name
                  (if (string-empty-p when-str) "" (format "(%s)" when-str)))))
    ;; Show only TODO entries with the selected tag:
    ;; org-tags-view: first arg non-nil => TODO-only
    (org-tags-view t (concat "+" tag))))
#+end_src
** mcordell/agenda-one-on-one
Prompts for a 1:1 name, then delegates to =mcordell/agenda-one-on-one-for-name= to show open TODOs tagged with that person.
#+begin_src emacs-lisp :tangle autoload/my-org.el
;;;###autoload
(defun mcordell/agenda-one-on-one ()
  "Prompt for a 1:1 name, then show open TODOs tagged with that person."
  (interactive)
  (let* ((names (mapcar #'car mcordell/one-on-one-list))
         (choice (completing-read "1:1 with: " names nil t)))
    (mcordell/agenda-one-on-one-for-name choice)))
#+end_src
** mcordell/insert-rrp-jira
#+begin_src emacs-lisp :tangle autoload/my-org.el
;;;###autoload
(defun mcordell/insert-rrp-jira ()
  "Insert a JIRA or GitHub PR link from the clipboard in Org-mode."
  (interactive)
  (let* ((clipboard-content (with-temp-buffer
                              (call-process "pbpaste" nil t)
                              (buffer-string)))
         (jira-url-regex "https://qcentrix.atlassian.net/browse/\\(RRP-[0-9]+\\)")
         (jira-key-regex "\\(RRP-[0-9]+\\)")
         (github-url-regex "https://github.com/q-centrix/\\(.*\\)/pull/[0-9]+")
         (jira-key (if (string-match jira-url-regex clipboard-content)
                       (match-string 1 clipboard-content)
                     (if (string-match jira-key-regex clipboard-content)
                         (match-string 1 clipboard-content)
                       nil)))
         (github-repo (if (string-match github-url-regex clipboard-content)
                          (match-string 1 clipboard-content)
                        nil)))
    (cond
     (jira-key
      (let ((jira-link (format "[[https://qcentrix.atlassian.net/browse/%s][%s]]" jira-key jira-key)))
        (insert jira-link)))
     (github-repo
      (let ((github-link (format "[[%s][%s PR]]" clipboard-content github-repo)))
        (insert github-link)))
     (t
      (message "No JIRA or GitHub link found in clipboard")))))
#+end_src
** mcordell/create-one-on-one-heading
Creates a heading for a one-on-one meeting with the given NAME on the next occurrence of the day and time specified in the one-on-one list.
The format for the heading is "* NAME 1-1 <Y-m-d a H:M>", where <Y-m-d a H:M> is the date and time of the next occurrence of the specified day and time.
Returns the formatted heading as a string.
#+begin_src emacs-lisp :tangle autoload/my-org.el
;;;###autoload
(defun mcordell/create-one-on-one-heading (name)
  (let* ((day-time (cdr (assoc name mcordell/one-on-one-list)))
         (today (current-time))
         (desired-day (parse-time-string day-time))
         (desired-dow (nth 6 desired-day))
         (desired-hour (nth 2 desired-day))
         (desired-min (nth 1 desired-day))
         (current-dow (nth 6 (decode-time today)))
         (days-until (- desired-dow current-dow)))
    (if (< days-until 0)
        (setq days-until (+ days-until 7)))
    (let ((next-meeting-date (time-add today (days-to-time days-until))))
      (format-time-string (concat "* " name " 1-1 <%Y-%m-%d %a %H:%M>")
                          (encode-time 0 desired-min desired-hour
                                       (nth 3 (decode-time next-meeting-date))
                                       (nth 4 (decode-time next-meeting-date))
                                       (nth 5 (decode-time next-meeting-date)))))))
#+end_src
** mcordell/org-agenda-todo-with-tag
#+begin_src emacs-lisp :tangle autoload/my-org.el
;;;###autoload
(defun mcordell/org-agenda-todo-with-tag ()
  (interactive)
  (let* ((tags-list '("jamaal" "chris" "andrew" "brian" "teo" "brad" "brad-b")) ; Define your list of tags here
         (tag (completing-read "Choose tag: " tags-list)))
    (org-tags-view nil (concat "TODO=\"TODO\"&" tag))))
#+end_src
** mcordell/create-one-on-one-heading-with-prompt
#+begin_src emacs-lisp :tangle autoload/my-org.el
;;;###autoload
(defun mcordell/create-one-on-one-heading-with-prompt ()
  (let* ((name (completing-read "Select a name: " (mapcar 'car mcordell/one-on-one-list)))
         (heading (mcordell/create-one-on-one-heading name)))
    heading))
#+end_src
** mcordell/create-simple-one-on-one-heading-with-prompt
#+begin_src emacs-lisp :tangle autoload/my-org.el
;;;###autoload
(defun mcordell/create-simple-one-on-one-heading-with-prompt ()
  (let* ((name (completing-read "Select a name: " (mapcar #'car mcordell/one-on-one-list))))
    (mcordell/create-simple-one-on-one-heading name)))
#+end_src
** mcordell/create-simple-one-on-one-heading
#+begin_src emacs-lisp :tangle autoload/my-org.el
;;;###autoload
(defun mcordell/create-simple-one-on-one-heading (name)
    (concat "* " name " 1-1 %^t"))
#+end_src
** mcordell/round-time-up
Smart time rounding for meeting scheduling. Rounds current time up to the next 30-minute or hour boundary.
Examples: 10:15 -> 10:30, 10:36 -> 11:00
#+begin_src emacs-lisp :tangle autoload/my-org.el
;;;###autoload
(defun mcordell/round-time-up ()
  "Round current time up to next 30-minute or hour boundary.
Examples: 10:15 -> 10:30, 10:36 -> 11:00"
  (let* ((now (decode-time))
         (current-hour (nth 2 now))
         (current-min (nth 1 now))
         (target-hour current-hour)
         (target-min 0))
    (cond
     ((= current-min 0) 
      (setq target-min 30))
     ((<= current-min 30) 
      (setq target-min 30))
     ((> current-min 30) 
      (setq target-hour (1+ current-hour)
            target-min 0)))
    (format-time-string "%Y-%m-%d %a %H:%M" 
                        (encode-time 0 target-min target-hour
                                     (nth 3 now) (nth 4 now) (nth 5 now)))))
#+end_src
** mcordell/create-meeting-heading-directly
Creates a meeting heading directly at the end of =mcordell/work-meeting-file= with smart time rounding. 
Avoids the org-capture workflow for a smoother experience.
#+begin_src emacs-lisp :tangle autoload/my-org.el
;;;###autoload
(defun mcordell/create-meeting-heading-directly (name)
  "Create a meeting heading directly in work-meeting-file with rounded time."
  (let* ((heading (format "* %s 1-1 <%s>" name (mcordell/round-time-up)))
         (file-buffer (find-file-noselect mcordell/work-meeting-file)))
    (with-current-buffer file-buffer
      (goto-char (point-max))
      (unless (bolp) (insert "\n"))
      (insert heading "\n")
      (save-buffer))
    ;; Return the position for focusing
    (list mcordell/work-meeting-file (with-current-buffer file-buffer (point)))))
#+end_src
** mcordell/read-time
Read a time string like “09:00” (adds “:00” if only an hour is given).
#+begin_src emacs-lisp :tangle autoload/my-org.el
;;;###autoload
(defun mcordell/read-time (prompt)
  "Read a time string like “09:00” (adds “:00” if only an hour is given)."
  (let* ((raw (read-string prompt nil nil
                           (format-time-string "%H:%M")))
         ;; Accept “9”, “9:30”, “09”, etc.
         (parts (split-string raw ":"))
         (hour  (format "%02d" (string-to-number (car parts))))
         (mins  (if (cadr parts) (cadr parts) "00")))
    (concat hour ":" mins)))
#+end_src
** mcordell/add-meetings-for-day
Prompt for a date, number of meetings, then loop to create headings.

Each heading has the form:

  * SUBJECT <YYYY-MM-DD HH:MM>

Entries are appended to =mcordell/work-meeting-file=
#+begin_src emacs-lisp :tangle autoload/my-org.el
;;;###autoload
(defun mcordell/add-meetings-for-day ()
  "Prompt for a date, number of meetings, then loop to create headings.

Each heading has the form:

  * SUBJECT <YYYY-MM-DD HH:MM>

Entries are appended to `mcordell/work-meeting-file`."
  (interactive)
  (let* ((date (org-read-date nil nil nil "Select meeting date: "))
         (count (read-number "Number of meetings to add: " 1)))
    (with-current-buffer (find-file-noselect mcordell/work-meeting-file)
      (goto-char (point-max))
      (dotimes (i count)
        (let* ((time (mcordell/read-time
                      (format "Start time for meeting %d (HH or HH:MM): "
                              (1+ i))))
               (subject (read-string
                         (format "Subject for meeting %d: " (1+ i)))))
          (insert (format "* %s <%s %s>\n" subject date time))))
      (save-buffer))
    (message "Added %d meeting%s to %s"
             count (if (= count 1) "" "s") mcordell/work-meeting-file)))
#+end_src
** +org/opened-buffer-files
#+begin_src emacs-lisp :tangle autoload/my-org.el
;;;###autoload
(defun +org/opened-buffer-files ()
  "Return the list of files currently opened in emacs"
  (delete-dups
   (append
    (delq nil (mapcar (lambda (x)
                        (if (and (buffer-file-name x)
                                 (string-match "\\.org$" (buffer-file-name x)))
                            (buffer-file-name x)))
                      (buffer-list)))
    (directory-files-recursively "~/org/qcentrix/people/" "\\.org$" nil)
    ))
  )
#+end_src
** +org/org-pass-link-to-system
#+begin_src emacs-lisp :tangle autoload/my-org.el
;;;###autoload
(defun +org/org-pass-link-to-system  ()
  "Return the list of files currently opened in emacs"
  (delete-dups
   (append
    (delq nil (mapcar (lambda (x)
                        (if (and (buffer-file-name x)
                                 (string-match "\\.org$" (buffer-file-name x)))
                            (buffer-file-name x)))
                      (buffer-list)))
    (directory-files-recursively "~/org/qcentrix/people/" "\\.org$" nil)
    ))
  )
#+end_src
** mcordell/one-on-one-workflow
Complete workflow for one-on-one meetings. This function:
1. Prompts for a person's name using =mcordell/one-on-one-list=
2. Searches for an existing meeting scheduled for today with that person
3. If found, focuses on that subtree
4. If not found, creates a new meeting heading directly in =mcordell/work-meeting-file= with smart time rounding (no disruptive org-capture)
5. After the meeting is set up, creates a vertical split with the agenda/tag view using =mcordell/agenda-one-on-one-for-name= (no double prompting)

#+begin_src emacs-lisp :tangle autoload/my-org.el
;;;###autoload
(defun mcordell/one-on-one-workflow ()
  "Start a one-on-one workflow: select person, find or create meeting, show agenda."
  (interactive)
  (let* ((names (mapcar #'car mcordell/one-on-one-list))
         (chosen-name (completing-read "1:1 with: " names nil t))
         (today-date (format-time-string "%Y-%m-%d"))
         (meeting-heading-pattern (format "^\\* %s 1-1 <%s" chosen-name today-date))
         (org-files (directory-files-recursively mcordell/one-on-one-files-dir "\\.org\\'"))
         (found-meeting nil))
    
    ;; Search for existing meeting today
    (catch 'meeting-found
      (dolist (file org-files)
        (with-current-buffer (find-file-noselect file)
          (save-excursion
            (goto-char (point-min))
            (when (re-search-forward meeting-heading-pattern nil t)
              (setq found-meeting (list file (point)))
              (throw 'meeting-found t))))))
    
    (if found-meeting
        ;; Found existing meeting - focus on it
        (progn
          (find-file (car found-meeting))
          (goto-char (cadr found-meeting))
          (org-show-subtree)
          (message "Found existing meeting for %s today" chosen-name))
      ;; No existing meeting - create new one directly
      (progn
        (let ((meeting-info (mcordell/create-meeting-heading-directly chosen-name)))
          (find-file (car meeting-info))
          (goto-char (cadr meeting-info))
          (org-show-subtree))
        (message "Created new meeting for %s" chosen-name)))
    
    ;; After meeting is set up, create vertical split with agenda view
    (split-window-right)
    (other-window 1)
    (mcordell/agenda-one-on-one-for-name chosen-name)))
#+end_src
* Config
** Vars
*** mcordell/work-org-directory
Define a directory for work org files
#+begin_src emacs-lisp :tangle config.el
(defvar mcordell/work-org-directory "~/org/qcentrix")
#+end_src
*** mcordell/one-on-one-list
#+begin_src emacs-lisp :tangle config.el
(defvar mcordell/one-on-one-list
  '(
    ("Andrew" . "Tuesday 12:00")
    ("Brad" . "Wednesday 15:00")
    ("Chris" . "Tuesday 12:30")
    ("David" . "Monday 13:00")
    ("Jamaal" . "Thursday 11:30")
    ("Jon" . "Friday 08:30")
    ("Nitin" . "Tuesday 06:30")
    ("Mark" . "Wednesday 11:00")
    ("Matt" . "Friday 11:30")
    ("Pierce" . "Wednesday 12:30")
    ("Preeti" . "Friday 12:00")
    ("Teo" . "Tuesday 14:30")
    ))
#+end_src
*** mcordell/one-on-one-files-dir
#+begin_src emacs-lisp :tangle config.el
(defvar mcordell/one-on-one-files-dir "~/org/qcentrix/" "Directory whose .org files are searched for 1:1 items.")
#+end_src
*** mcordell/work-meeting-file
Org file where meeting headings are stored.
#+begin_src emacs-lisp :tangle config.el
(defvar mcordell/work-meeting-file "~/org/qcentrix/meetings.org" "Org file where meeting headings are stored.")
#+end_src

** Main Config
*** org configuration
**** Keywords
#+begin_src emacs-lisp :tangle config.el
(after! org
  (setq org-todo-keywords
        '((sequence
           "TODO(t)"             ; A task that needs doing & is ready to do
           "PROJ(p)"             ; A project, which usually contains other tasks
           "LOOP(r)"             ; A recurring task
           "QUEST(q)"            ; A question
           "STRT(s)"             ; A task that is in progress
           "WAIT(w@/!)"          ; Something external is holding up this task
           "HOLD(h)"             ; This task is paused/on hold because of me
           "IDEA(i)"             ; An unconfirmed and unapproved task or notion
           "DELG(l@/!)"
           "|"
           "DONE(d)"    ; Task successfully completed
           "KILL(k)")   ; Task was cancelled, aborted or is no longer applicable
          (sequence
           "[ ](T)"                     ; A task that needs doing
           "[-](S)"                     ; Task is in progress
           "[?](W)"                     ; Task is being held up or paused
           "|"
           "[X](D)")                    ; Task was completed
          (sequence
           "|"
           "OKAY(o)"
           "YES(y)"
           "NO(n)"))
        org-todo-keyword-faces
        '(("[-]" . +org-todo-active)
          ("STRT" . +org-todo-active)
          ("QUEST" . +org-todo-active)
          ("[?]" . +org-todo-onhold)
          ("WAIT" . +org-todo-onhold)
          ("DELG" . +org-todo-onhold)
          ("HOLD" . +org-todo-onhold)
          ("PROJ" . +org-todo-project)
          ("NO" . +org-todo-cancel)
          ("KILL" . +org-todo-cancel))
        org-default-priority 67))
#+end_src
**** Main
#+begin_src emacs-lisp :tangle config.el
(after! org
  (add-hook 'org-open-link-functions '+org/org-pass-link-to-system)
  (set-company-backend! 'org-mode '(company-capf))
  (setq org-refile-targets '((+org/opened-buffer-files :maxlevel . 9))
        org-refile-use-outline-path 'file
        org-outline-path-complete-in-steps nil
        org-refile-allow-creating-parent-nodes 'confirm
        )
  )
#+end_src
*** capture templates
#+begin_src emacs-lisp :tangle config.el
(after! org (setq-default org-capture-templates '(("s" "ruby snippet" entry (file "~/org/notes.org")
                                                   "* Snippet: %a
,#+BEGIN_SRC %^{sourcetype}
 %c
,#+END_SRC")

                                                  ("t" "Task" entry (file "~/org/todos.org")
                                                   "* TODO %?
 %i
 %a")
                                                  ("n" "note" entry (file "~/org/notes.org")
                                                   "* %? :NOTE:

%U
%a
")                                                 ("i" "idea" entry (file "~/org/inbox.org")
                                                   "* %?

%U
%a
")
                                                  ("r" "review" entry (file+headline
                                                                       "~/org/qcentrix/qcentrix.org"
                                                                       "Reviews")
                                                   "** TODO [[%c][%^{description}]] :%^{repo|reg-api|reg-imp|reg-web}:")

                                                  ("o" "One on One" entry
                                                   (file "~/org/qcentrix/big_board.org")
                                                   "%(mcordell/create-one-on-one-heading-with-prompt)
%?"
                                                   :empty-lines 1
                                                   :unnarrowed t
                                                   :jump-to-captured t
                                                   )
                                                  ("g" "simple o3" entry (file mcordell/work-meeting-file)
                                                   "%(mcordell/create-simple-one-on-one-heading-with-prompt)
%?"
                                                   :empty-lines 1
                                                   :unnarrowed t
                                                   :jump-to-captured t
                                                   )
                                                  ("m" "Meeting" entry (file "~/org/qcentrix/qcentrix.org")
                                                   "* %^{Subject} %^t<%<%Y-%m-%d %H:00>>
%?
")
                                                  ("a" "q-centrix task" entry (file+headline "~/org/qcentrix/big_board.org" "Tasks")
                                                   "* TODO %^{Subject}
%?
")
                                                  ("x" "Q-Centrix Note" entry (file
                                                                               "~/org/qcentrix/qcentrix.org")
                                                   "* %? %t
"))


                          )
  )
#+end_src

*** agenda views
#+begin_src emacs-lisp :tangle config.el
(after! org
  (setq org-agenda-custom-commands '(
                                     ("o" "Work tasks"
                                      ((tags-todo "*"
                                                  ((org-agenda-overriding-header "Work tasks")))
                                       )
                                      ((org-agenda-files
                                        (directory-files-recursively "~/org/qcentrix/" "\\.org\\'")))
                                      )
                                     ("w" "multiple"
                                      ((agenda ""
                                               ((org-agenda-start-day "0d")
                                                (org-agenda-span 1)
                                                (org-deadline-warning-days 3)  ; Show deadlines only for the next 3 days
                                                ;; Keep only TODO/QUEST items in the agenda block
                                                (org-agenda-skip-function
                                                 (lambda ()
                                                   (save-excursion
                                                     (org-back-to-heading t)
                                                     (let ((kw (org-get-todo-state)))
                                                       (unless (member kw '("TODO" "QUEST"))
                                                         (or (outline-next-heading) (point-max)))))))))
                                       ;; High priority list, limited to TODO|QUEST and A/B priority
                                       (tags-todo "+TODO={TODO\\|QUEST}+PRIORITY={A\\|B}"
                                                  ((org-agenda-overriding-header "High Priority:")
                                                   (org-agenda-sorting-strategy '(priority-down)))))
                                      ;; Settings applied to all blocks in this command
                                      ((org-agenda-files
                                        (directory-files-recursively "~/org/qcentrix/" "\\.org\\'"))))                                       )
        )
  )
#+end_src
** Org-mac-link extension
#+begin_src emacs-lisp :tangle config.el
(use-package! org-mac-link
  :after org
  :init
  (defun as-get-selected-finder-items ()
    (do-applescript (concat "tell application \"Finder\"\n" " set theSelection to the selection\n"
                            " set links to {}\n" " repeat with theItem in theSelection\n"
                            " set theLink to \"file+sys://\" & (POSIX path of (theItem as string)) & \"::split::\" & (get the name of theItem) & \"\n\"\n"
                            " copy theLink to the end of links\n" " end repeat\n"
                            " return links as string\n" "end tell\n")))

  (defun as-get-selected-mailmate-message ()
    (do-applescript (concat "tell application \"MailMate\"\n" " set allMessages to messages\n"
                            " set theMessage to item 1 of allMessages\n"
                            " return (message url of theMessage) & \"::split::\" & (name of theMessage)\n"
                            " end tell\n")))
  (defun org-mac-mailmate-item-get-selected ()
    (interactive)
    (message "Applescript: Getting mailmate message...")
    (org-mac-link-paste-applescript-links (as-get-selected-mailmate-message)))

  (defun org-mac-mailmate-insert-selected ()
    (interactive)
    (insert (org-mac-mailmate-item-get-selected)))
  (defun org-mac-link-applescript-chrome-get-frontmost-url ()
    "AppleScript to get the links to the frontmost window of the Chrome.app."
    (let ((result
           (org-mac-link-do-applescript
            (concat
             "set frontmostApplication to path to frontmost application\n"
             "tell application \"Brave\"\n"
             "	set theUrl to get URL of active tab of first window\n"
             "	set theResult to (get theUrl) & \"::split::\" & (get name of window 1)\n"
             "end tell\n"
             "activate application (frontmostApplication as text)\n"
             "set links to {}\n"
             "copy theResult to the end of links\n"
             "return links as string\n"))))
      (replace-regexp-in-string
       "^\"\\|\"$" "" (car (split-string result "[\r\n]+" t)))))

  )
#+end_src
** Calendar tooling
#+begin_src emacs-lisp :tangle config.el
(use-package! calfw-org
  :after org
  :config
  (defun my/open-calendar ()
    (interactive)
    (cfw:open-org-calendar)))

(after! calfw
  ;; Custom RET handler
  (defun my/cfw-open-entry-at-point ()
    "Show the calendar item details at point, if any."
    (interactive)
    (let ((cp (cfw:get-cur-cell)))
      (when cp
        (let ((contents (cfw:cp-get-contents cp)))
          (if contents
              (cfw:show-details contents)
            (message "No entry under cursor."))))))

  ;; Override RET key in calendar view
  (define-key cfw:calendar-mode-map (kbd "RET") #'my/cfw-open-entry-at-point))
#+end_src
